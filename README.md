# Mx* Compiler Project for SJTU MS208

## Overview
The course repository: [Compiler 2020](https://github.com/peterzheng98/Compiler-2020) 

The source language is Mx*, a java-like language. The target is risc-v assembly. There are mainly three stages: semantic, codegen and optimize.

## Semantic Stage

### Lexer and Parser
Antlr4 is a powerful tool to generate **lexer** and **parser** by a sample **g4** file. 

### Abstract Syntax Tree
**CST**(Concrete Syntax Tree) is a representation of grammars in a tree-like form. **AST**(Abstract Syntax Tree) can be considered as a simplified CST but still contains useful information for semantic check. We can traverse CST using **BaseVisitor**(generated by antlr4) to build AST. 

### Semantic Check
Build an implicit **scope tree** and **symbol tree**. Lots of details and strange cases like (new int[10])[0]. The only thing to do is data-oriented program and check.

## Codegen Stage

### Intermediate Representation

**LLVM** is a great IR. If we follow the rule of llvm, the codegen generation and optimization will be easier and more efficient. And we don't need too much time to design personal IR. Although the design and implemention is much easier, the homework becomes a little boring. In my opinion, the most difficult work is to design an efficient IR.

See [llvm langdef](https://llvm.org/docs/LangRef.html)

### Instruction Selection

Translate IR to pesudo risc-v assembly. We can do some optimizations in the process, such as:

- replace **a + a** or **a * 2** with **a << 1**.
- 
```
%ptr = getelementptr i32, i32* array, i32 1
%res = load i32, i32* %ptr
```
  
  We can translate the above IR code into **lw res,4(array)** instead of **addi ptr,4(array)**; **lw res,0(ptr)**.
  
### Register Allocation
See Chapter 11 in Tiger Book. Although the algorithm is difficult understand for me, there's pesudo code in tiger book.

## Optimize Stage

### Mem2reg
The definition of **SSA(Static Single Assignment)** in [SSA book](http://ssabook.gforge.inria.fr/latest/book.pdf):

    A program is defined to be in SSA form if each variable is a target of exactly one assignment statement in the program text. 

But to implement LLVM-IR with SSA directly is a little hard, so we firstly implement pesudo-LLVM then restruct it to real LLVM-IR. In pesudo-LLVM, all defitions of variables are by **store** instructions and all uses of variables are by **load** instructions. For example,
```
int a = 1, b = 2;
int c = a + b;
```
The pesudo-LLVM of the above code is
```
%a_address = alloca i32
store i32 1, i32* %a_address
%b_address = alloca i32
store i32 2, i32* %b_address
%c_address = alloca i32
%a = load i32, i32* %a_address
%b = load i32, i32* %b_address
%c = add i32 %a, %b
store i32 %c i32* %c_address
```
In other words, we achieve pesudo-SSA by sacrificing memory access. The **mem2reg** optimization is just to elimitate these expensive memory access. The algorithm is in chapter 2 of [SSA book](http://ssabook.gforge.inria.fr/latest/book.pdf).

### CFG Simplification
In the **CFG(control flow graph)**, vertexes represent basic blocks and edges represent jump instructions in the control flow. **CFG Simplification** includes removing unreachable blocks, simplifying constant branches and simplifying single path phi-instructions. 

### Inliner 

### Dead Code Elimitation

### Sparse Conditional Constant Propagation    
